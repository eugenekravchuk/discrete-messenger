"""
RSA algorithm
"""
import math


def gcd(a, h):
	"""
	визначення експоненти шифрування 
	"""
	temp = 0
	while(1):
		temp = a % h
		if (temp == 0):
			return h
		a = h
		h = temp

#По-перше, в коді встановлюються значення простих чисел p та q, які використовуються для генерації ключів.
#Вони використовуються для обчислення модулю n, що дорівнює p * q. Потім обчислюється значення функції Ейлера phi,
#яке дорівнює (p-1)*(q-1).Після цього виконується цикл, що перебирає можливі значення e, починаючи з 2.
#Кожне нове значення e перевіряється на взаємну простоту з phi (за допомогою функції gcd(e, phi)).
#Якщо значення e виявляється взаємно простим з phi, цикл зупиняється.

p = 3
q = 7
n = p*q
e = 2
phi = (p-1)*(q-1)

while (e < phi):
	if(gcd(e, phi) == 1):
		break
	e = e+1

k = 2
#Код обчислює приватний ключ d, який є мультиплікативно оберненим до e за модулем phi
d = (1 + (k*phi))/e

msg = 12.0

print("Message data = ", msg)

#Вхідне повідомлення (msg) шифрується, використовуючи відкритий ключ (e, n). 
#Шифрування відбувається за допомогою виразу c = pow(msg, e) % n, де c - зашифроване повідомлення.
c = pow(msg, e)
c = math.fmod(c, n)
print("Encrypted data = ", c)

#Зашифроване повідомлення (c) розшифровується за допомогою приватного ключа d та модулю n. 
#Це виконується за допомогою виразу m = pow(c, d) % n, де m - оригінальне повідомлення.
m = pow(c, d)
m = math.fmod(m, n)
print("Original Message Sent = ", m)